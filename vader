#!/usr/bin/python

import click
import sys
import time

from ops import colour
from ops import connection

command_file = connection.get_json()

class Operations(object):
    ''' Take out operations '''
    
    def take_out_switch(self, switch):
        print 'No ports entered'
        print 'Proceeding with prechecks for %s ...' % switch
        protocols_to_take = Operations()._precheck_switch(switch)

        if not protocols_to_take:
            print colour.warning('No running routing protocols on %s') % switch
            sys.exit()

        if 'ospf' in protocols_to_take:
            Operations()._take_out_ospf(switch)

        if 'bgp' in protocols_to_take:
            Operations()._take_out_bgp(switch)
            
        print colour.notify('Saving config ...')
        time.sleep(1)
        save_return = connection.send_command(switch, command_file["take"]["out"]["post"]["save_config"])
        
        if '[OK]' in save_return:
            print colour.good('Config successfully saved')
            print colour.good('Done.')
            sys.exit()
        else:
            print colour.warning('Config unsuccessfully saved')
            print colour.warning('Done.')
            sys.exit()
            
            
    def _precheck_switch(self, switch):
        ''' Get pre-take switch information '''
        
        print 'Checking running routing daemons ...'
        while True:
            try:
                routing_daemons = connection.send_command(switch, command_file["take"]["out"]["pre"]["switch"]["routing"]["daemons"])
            except ValueError as e:
                time.sleep(1)
                continue
            break
            
        configured_routing = connection.send_command(switch, command_file["take"]["out"]["pre"]["switch"]["routing"]["configuration"])

        print '-------' * 6
        print 'Running routing protocols:'

        protocols_to_take = []

        if 'ospf' in routing_daemons:
            print colour.good('%s is running OSPF') % switch
            if 'ospf' in configured_routing:
                print colour.good('%s is configured with OSPF') % switch
                protocols_to_take.append('ospf')
            else:
                print colour.warning('%s is not configured with OSPF') % switch

        if 'bgp' in routing_daemons:
            print colour.good('%s is running BGP') % switch
            if 'bgp' in configured_routing:
                print colour.good('%s is configured with BGP') % switch
                protocols_to_take.append('bgp')
            else:
                print colour.warning('%s is not configured with BGP') % switch

        print '-------' * 6

        time.sleep(1)
        return protocols_to_take


    def _take_out_ospf(self, switch):
        ''' Take out OSPF '''
        
        time.sleep(1)
        print colour.notify('Taking out OSPF on %s ...') % switch
        print 'Applying max-metric ...'
        time.sleep(2)
        result = connection.send_command(switch, command_file["take"]["out"]["switch"]["ospf"])

        if not result:
            print colour.good('OSPF was taken out successfully on %s') % switch
        else:
            print colour.warning('Take out of OSPF was unsuccessful %s') % switch
            print result
            sys.exit()


    def _take_out_bgp(self, switch):
        ''' Branching function to get BGP info and choose to take out IBGP and/or EBGP '''
        
        time.sleep(1)
        print colour.notify('Taking out BGP on %s ...') % switch
        print 'Getting local AS for %s ...' % switch
        time.sleep(1)
        local_as = connection.send_command(switch, command_file["take"]["out"]["pre"]["switch"]["bgp"]["local_as"])
        print 'Local BGP AS: %s on %s' % (local_as, switch)
        time.sleep(2)
        
        print 'Getting BGP neighbors for %s ...' % switch
        time.sleep(2)
        return_neighbors = connection.send_command(switch, command_file["take"]["out"]["pre"]["switch"]["bgp"]["neighbors"])
        
        bgp_neighbors = return_neighbors.split(' ')
        bgp_neighbors = dict(map(str, value.split(':')) for value in bgp_neighbors)
        
        take_out_ebgp = False
        
        for neighbor, as_number in bgp_neighbors.iteritems():            
            if local_as != as_number:
                take_out_ebgp = True
                
        if take_out_ebgp is False:
            return_ibgp = Operations()._take_out_ibgp(switch, local_as, bgp_neighbors)
            if return_ibgp is 'good':
                print colour.good('IBGP was taken out successfully on %s') % switch
            else:
                print colour.warning('IBGP was taken out unsuccessfully on %s') % switch
                sys.exit()
                
        elif take_out_ebgp is True:
            return_ebgp = Operations()._take_out_ebgp(switch, local_as, bgp_neighbors)
            if return_ebgp is 'good':
                print colour.good('EBGP and IBGP were taken out successfully on %s') % switch
            else:
                print colour.warning('EBGP and IBGP were taken out unsuccessfully on %s') % switch
                sys.exit()           
            

    def _take_out_ibgp(self, switch, local_as, bgp_neighbors):
        ''' Take out IBGP '''
        
        print colour.notify('Taking out IBGP on %s ...') % switch
        
        ssh_connection = connection.get_connection(switch)
        
        print 'Applying route-map TAKE_OUT_IBGP to:'
        for neighbor, as_number in bgp_neighbors.iteritems():
            print '\tNeighbor: %s AS: %s' % (neighbor, as_number)
            command_output = ssh_connection.send_command(command_file["take"]["out"]["switch"]["bgp"]["ibgp"].format(local_as, neighbor))
            
        if not command_output:
            return 'good'
        else:
            print command_output
            return 'bad'
        
    
    def _take_out_ebgp(self, switch, local_as, bgp_neighbors):
        ''' Take out EBGP '''
        
        print colour.notify('Taking out IBGP and EBGP on %s ...') % switch
        print 'IBGP first ...'
        
        ssh_connection = connection.get_connection(switch)
        
        print 'Applying route-map TAKE_OUT_IBGP to:'
        for neighbor, as_number in bgp_neighbors.iteritems():
            if local_as == as_number:
                print '\tNeighbor: %s AS: %s' % (neighbor, as_number)
                command_output_ibgp = ssh_connection.send_command(command_file["take"]["out"]["switch"]["bgp"]["ibgp"].format(local_as, neighbor))
        
        print 'Now EBGP ...'
        time.sleep(1)
        print 'Applying route-map TAKE_OUT_EBGP to:'
        for neighbor, as_number in bgp_neighbors.iteritems():
            if local_as != as_number:
                print '\tNeighbor: %s AS: %s' % (neighbor, as_number)
                command_output_ebgp = ssh_connection.send_command(command_file["take"]["out"]["switch"]["bgp"]["ebgp"].format(local_as, neighbor))
                
        if not command_output_ibgp or not command_output_ebgp:
            return 'good'
        else:
            return 'bad'


    def take_out_port(self, switch, port):
        ''' Take out port '''
        
        port_take_out_proceed = Operations()._precheck_port(switch, port)
        
        if port_take_out_proceed is 'bad':
            print colour.warning('Shutting %s would isolate switch ...') % port
            print colour.warning('Done.')
            sys.exit()
        elif port_take_out_proceed is 'good':
            print colour.good('%s will not be isolated ...') % switch
            
        ssh_connection = connection.get_connection(switch)
        return_take_out_port = ssh_connection.send_command(command_file["take"]["out"]["port"].format(port))
        
        if not return_take_out_port:
            print colour.good('%s was taken out successfully') % port
            print colour.good('Done.')
            sys.exit()
        else:
            print colour.warning('%s was taken out unsuccessfully') % port
            print colour.warning('Done.')
            sys.exit()
        
        
    def _precheck_port(self, switch, port):
        print 'Proceeding with prechecks for %s on %s ...' % (port, switch)
        return_port_list = connection.send_command(switch, command_file["take"]["out"]["pre"]["port"]["list"])
        
        port_count = 0
        
        for return_port in return_port_list:
            if return_port != port:
                port_count += 1
                
        if port_count is 0:
            return 'bad'
        else:
            return 'good'


    ''' Take back operations '''
    def take_back_switch(self, switch):
        print colour.notify('No ports entered')
        print colour.notify('Proceeding with prechecks for %s') % switch
        pass


    def take_back_port(self, switch, port):
        print colour.notify('Proceeding with prechecks for %s on %s') % (port, switch)
        pass
            
                
class TakeOut(object):
    ''' Take switch or port out of service '''

    @click.command(help='Take switch and/or ports out of service')
    @click.option('-s', '--switch', default='localhost', help='Name or IP of target switch')
    @click.option('-p', '--port', default=None, help='ID or IP of the target port')
    @click.pass_obj
    def out(self, switch, port):
        TakeOut()._decide_operation_out(switch, port)


    def _decide_operation_out(self, switch, port):
        if not port:
            Operations().take_out_switch(switch)
        else:
            Operations().take_out_port(switch, port)


class TakeBack(object):
    ''' Take switch or port back into service '''

    @click.command(help='Take switch and/or ports back into service')
    @click.option('-s', '--switch', default='localhost', help='Name or IP of target switch')
    @click.option('-p', '--port', default=None, help='ID or IP of the target port')
    @click.pass_obj
    def back(self, switch, port):
        TakeBack()._decide_operation_back(switch, port)


    def _decide_operation_back(self, switch, port):
        if not port:
            Operations().take_back_switch(switch)
        else:
            Operations().take_back_port(switch, port)
            
            
class TakeStatus(object):
    ''' Get current take status of switch '''
    
    @click.command(help='Check the current status of switch')
    @click.pass_obj
    def status():
        pass


# Main body
@click.group()
@click.pass_context
def main(ctx):
    '''
    \b
    kirk is a cli tool for taking out/back switches and ports running MOSS
    Developed by and Copyright 2016 of Matthew Lovatt
    '''

main.add_command(TakeOut.out)
main.add_command(TakeBack.back)
main.add_command(TakeStatus.status)


if __name__=='__main__':
    main()
